local Frame = require("system.frame")
local dungeon_manager = class("dungeon_manager", Frame)

-----副本系统解锁
Event.decl(dungeon_manager, "unlock_dungeon_system")
----解锁新副本
Event.decl(dungeon_manager, "unlock_new_dungeon")
---副本不存在，撞门时弹出选择难度进入副本的面板
Event.decl(dungeon_manager, "open_dungeon_join")
----创建副本时收到的消息
Event.decl(dungeon_manager, "join_dungeon_first")
----请求当前进度
Event.decl(dungeon_manager, "refresh_dungeon_progress")
-----副本存在的情况下进入副本
Event.decl(dungeon_manager, "join_dungeon")
---如果副本已经存在，撞门的时候会弹出进度，重置面板
Event.decl(dungeon_manager, "before_enter_dungeon")

function dungeon_manager:doInit()
    ----所有副本的id，这是一个列表
    self.m_dungeon_list = {}
    ---所有副本的可以用到的信息，这是一个字典，以id为键
    self.m_dungeon_dic = {}
    ----副本的总表
    self.m_dungeon_info_dic = {}
    ----副本的进度
    self.m_dungeon_progress = {}
    ----副本的Boss拾取进度
    self.m_drag_progress = {}
    ----当前副本的id
    self.m_dungeon_id = nil
    for k, v in pairs(dbc.instances) do
        self.m_dungeon_info_dic[k] = v
    end
end

function dungeon_manager:init()
    self:local_log("dungeon_manager  初始化")
    self:req_unlock_dungeon_list()
end

--服务器返回解锁列表
function dungeon_manager:accept_unlock_dungeon_list(unlock_dungeon_list)
    self.m_dungeon_list = unlock_dungeon_list
    ----temp test
    --self.m_dungeon_list[2] = 12
    --self.m_dungeon_list[3] = 13
    --self.m_dungeon_list[4] = 14
    --self.m_dungeon_list[5] = 15
    -----
    --for k, v in pairs(self.m_dungeon_list) do
    --    Debug.LogError("gain_is_dungeon_unlock"..tostring(k))
    --    Debug.LogError("gain_is_dungeon_unlock"..tostring(v))
    --end
    if #self.m_dungeon_list > 0 then
        self:emit_event("unlock_dungeon_system")
    end
    ----维护客户端的一个字典来存储副本的信息
    for k, v in pairs(self.m_dungeon_list) do
        local in_map_id = dbc.instances[v].inst_map_id
        local level_name = dbc.instances[v].diff_name
        local data = { ["map_id"] = in_map_id, ["level_name"] = level_name }
        self.m_dungeon_dic[v] = data
    end
end

----接受服务器反回的地图id结果
function dungeon_manager:accept_dungeon_diff_result(acc_map_id)
    --这里是返回了一个地图的map_id，要在总的表中根据map_id找出对应的id，再找出此副本所拥有的难度类型，
    self:local_log("收到了服务器传来的消息%s", acc_map_id)
    local curr_map_level_list = {}
    for k, v in pairs(self.m_dungeon_info_dic) do
        if v.inst_map_id == acc_map_id then
            curr_map_level_list[k] = v.diff_name
        end
    end

    -----之后再从已经解锁的表当中来确定哪些难度可以进入，哪些难度不可以进入，这个主要用来判断按钮变灰，是否可以点击
    --------本map_id对应的难度list，在值中1表示普通，2表示英雄，3表示史诗，4表示秘境
    local open_diff_list = {}
    for k, v in pairs(curr_map_level_list) do
        if v == "普通" then
            open_diff_list[1] = { ["level"] = 1, ["ret_id"] = k, ["state"] = 0 }
        elseif v == "英雄" then
            open_diff_list[2] = { ["level"] = 2, ["ret_id"] = k, ["state"] = 0 }
        elseif v == "史诗" then
            open_diff_list[3] = { ["level"] = 3, ["ret_id"] = k, ["state"] = 0 }
        elseif v == "秘境" then
            open_diff_list[4] = { ["level"] = 4, ["ret_id"] = k, ["state"] = 0 }
        end
    end

    for k, v in pairs(self.m_dungeon_dic) do
        if v["map_id"] == acc_map_id then
            if v["level_name"] == "普通" then
                open_diff_list[1]["state"] = 1
            elseif v["level_name"] == "英雄" then
                open_diff_list[2]["state"] = 1
            elseif v["level_name"] == "史诗" then
                open_diff_list[3]["state"] = 1
            elseif v["level_name"] == "秘境" then
                open_diff_list[4]["state"] = 1
            end
        end
    end

    ---触发打开dunjeon_join面板
    self:emit_event("open_dungeon_join", open_diff_list)
end

--解锁新副本
function dungeon_manager:accept_unlock_new_dungeon(dungeon_id)
    self:do_add_dungeon(dungeon_id)
end

---向服务器请求解锁列表
function dungeon_manager:req_unlock_dungeon_list()
    self:base_call("req_unlock_instances")
end

----被拉入副本时服务器传来时间和当前副本的进度
function dungeon_manager:accept_dungeon_time_and_progress(time, progress_arry, drag_arry)
    self:local_log("进入副本传来的时间        %s", time)
    for k, v in pairs(progress_arry) do
        self:local_log("进入副本kzhi         %s", k)
        self:local_log("进入副本vzhi       %s", v)
    end
    self.m_dungeon_progress = progress_arry
    -----抛出进入副本的事件
    self.m_drag_progress = drag_arry
    self:emit_event("join_dungeon_first", time, progress_arry, drag_arry)
end

----当打开副本地图的时候向服务器请求，服务器返回副本的进度的回调
function dungeon_manager:accept_dungeon_progress(progress_arry)
    self.m_dungeon_progress = progress_arry
    self:emit_event("refresh_dungeon_progress", progress_arry)
end

---向副本的列表中添加新解锁的副本id
function dungeon_manager:do_add_dungeon(dungeon_id)
    if #self.m_dungeon_list == 0 then
        self:emit_event("unlock_dungeon_system")
    end
    ---向副本列表中添加
    self.m_dungeon_list[#self.m_dungeon_list + 1] = dungeon_id

    ---向副本字典中添加
    local map_id = dbc.instances[dungeon_id].map_id
    local level_name = dbc.instances[dungeon_id].diff_name
    local data = { ["map_id"] = map_id, ["level_name"] = level_name }
    self.m_dungeon_dic[dungeon_id] = data
    self:emit_event("unlock_new_dungeon", dungeon_id)
end

-----接受进入副本时同步副本已经进行了多少秒，这个协议只有副本已经存在并且重新进入副本的时候才会收到
function dungeon_manager:accept_dungeon_time(time)
    self:emit_event("join_dungeon", time)
end

---当副本已经存在的时候撞门会弹出进度板，此进度板会有重置的功能
function dungeon_manager:accept_dungeon_reset_and_progress(id, progress_arry, drag_arry, reset)
    --Debug.LogError("dungeon_manager"..tostring(id))
    self.m_dungeon_id = id
    self.m_dungeon_progress = progress_arry
    self.m_drag_progress = drag_arry
    --for k, v in ipairs(drag_arry) do
    --    Debug.LogError("drag_progressV的值为......" .. tostring(v))
    --end
    --for k, v in ipairs(progress_arry) do
    --    Debug.LogError("dungeon_progressV的值为......" .. tostring(v))
    --end
    self:emit_event("before_enter_dungeon", id, progress_arry, drag_arry, reset)
end

-----获取当前所在副本的id  外界调用
function dungeon_manager:gain_curr_dungeon_id()
    local id = self.m_dungeon_id
    return id
end

----获取服务器发来的boss拾取进度
function dungeon_manager:gain_drag_progress()
    local ret = self.m_drag_progress
    return ret
end

-----获取当前副本的进度
function dungeon_manager:gain_dungeon_progress()
    local progress = self.m_dungeon_progress
    return progress
end

----获取当前的主角所在的副本id
function dungeon_manager:gain_inst_id()
    local kbe_mgr = self:getFrame("kbe.kbe_mgr")
    local sdk = app:getKBESDK()
    local role_id = sdk:get_player_id()
    local role = kbe_mgr:get_entity(role_id)
    local id = role:get_inst_id()
    return id
end

----外界获取副本列表
function dungeon_manager:show_dungeon_list()
    local ret = {}
    for k, v in pairs(self.m_dungeon_list) do
        ret[k] = v
    end
    return ret
end

function dungeon_manager:base_call(method_name, ...)
    local kbesdk = app:getKBESDK()
    local player_id = kbesdk:get_player_id()
    kbesdk:entity_base_call(player_id, method_name, ...)
end

function dungeon_manager:cell_call(method_name, ...)
    local kbesdk = app:getKBESDK()
    local player_id = kbesdk:get_player_id()
    kbesdk:entity_cell_call(player_id, method_name, ...)
end

function dungeon_manager:local_log(...)
    --app:logError(string.format(...))
end

return dungeon_manager